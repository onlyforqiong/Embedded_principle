# 嵌入式系统原理与应用 期末复习
## 第二章 ARM 处理器体系结构
### arm处理器概述
- ARM(advanced risc machines )处理器 risc 结构的高性价比，低功耗，广泛用于各种嵌入式设计中
- ARM cpu基本结构
    - 算数逻辑单元(ALU)
    - 寄存器(Registers)
        - 通用寄存器(R0 to R12) and PC寄存器
    - 指令译码器
    - 总线接口单元(BIU)
- 冯诺依曼瓶颈
    - 将cpu与存储器并非十全十美
    - cpu与存储器之间的流量与存储器的容量相比非常小，某些情况下数据流量成为整体效率非常严重的限制
    - cpu速度远大于存储器读写速率
    - 增加缓存，分支预测，指令流和数据流分开
- 哈佛结构
    - 程序指令存储和数据存储分开的存储器结构(split cache)
- 如何提高cpu速度
    - 提高时钟频率 带来热量功耗 工艺限制
    - 改变架构 risc 流水线
- RISC vs CISC
    - CISC:在cpu中设计尽可能多的指令
    - RISC:减少指令的个数
        - 单周期执行
        - 哈佛结构:指令与操作数的总线分离，采用流水线操作
          - 指令与操作数可以同时进出cpu
          - 在通用计算机方面带来更高代价
        - 简单的地址模式
          - 方便用硬连线控制，而不是用伪代码，增加了汇编编写的难度
        - 指令大小固定，使得指令解码器更容易实现 CISC指令长度可能是不同长度的
        - 减少指令个数 导致使用更多的存储器
        - load/store 指令架构
        - risc处理器至少有32个寄存器，ARM有十六个通用寄存器
        - 减少对于堆栈和内存的使用
- 流水线技术
  - 允许多个操作同时处理，而非顺序
  - 如何充分利用流水线
    - 使用简单的代码
      - 尽量不使用跳转，并且如果使用跳转尽量每次跳转到同样的方向
      - 复杂的设计，动态跳转表，无论是处理器还是编译器都无法做到很好的预测处理
    - 使用简单的数据结构
      -  保持数据顺序、相邻连续可以组织数据停顿
- 超标量 superscalar
- 乱序执行(out of order execute)
### cortex-A8处理器架构
- 基于ARMV7架构的应用处理器
- 使用了更高性能、更低功耗、更高代码密度的Thumb-2技术
  - 新增了130条指令
  - 新增的功能使用户在进行终端服务时无需在ARM和Thumb模式之间进行切换
  - 产生的代码保持Thumb指令的传统代码密度，却可以实现32位ARM的性能
  - 首次采用面向音频、视频和3D图形的NEON媒体和信号处理技术
  - 采用了Jazelle-RCT Java加速技术
  - TrustZone技术是ARM为实现安全的硬件基础设施而开发的技术。
    它通过在CPU上加入两个完整但互相隔离的作业环境来分割处理器资源。分别称为:
    Secure world:安全世界
    Normal world:普通世界
    正常世界运行常规应用程序和操作系统,安全世界用于运行安全敏感的应用程序和代码。
    为了实现世界之间的隔离,TrustZone提供了下面几个特性:
    单独的信号线:Secure world和Normal world有独立的中断和总线信号线;
    硬件资源隔离:两部分世界有独立的内存、寄存器空间和其他硬件资源;
    安全执行模式:CPU可进入Secure或者Non-secure模式。
    以上这些让Secure world和Normal world互相隔绝,保护Secure world代码和数据不受Normal world干扰。
    TrustZone让设备具有"双重身份":
    Normal world运行常规应用,提供日常功能;
    Secure world运行安全应用,提供安全功能。
    这让设备能同时提供开放性和保密性,在不影响用户体验的情况下实现安全需求。
    主要应用于移动支付、 biometrics识别、 DRM数字版权等需要高安全级别的场景。
    TrustZone是ARM为实现安全可靠的移动和嵌入式设备而设计的安全硬件架构。
- IFU指令读取单元
  - I侧ram cache tlb bru    
- 指令译码单元(instruction Decoder)
  - 指令译码单元对所有的ARM、thumb-2指令进行译码排序，包括调试控制协处理器的指令
  - 处理指令的顺序
    - 异常
    - 调试事件
    - 复位初始化
    - 存储器内嵌自测
    - 等待中断
    - 其他事件
- 指令执行单元
  - 两个对称的ALU 超标量
  - 配置乘法器和加载存储流水线
  - 指令执行单元
    - 执行所有整数ALI运算和乘法运算，并修改标志位
    - 根据要求产生用于存取的虚拟地址以及基本回写值
    - 将要存放的数据格式化，并将数据和标志向前发送
    - 处理分支及其它指令流变化，并评估指令条件码
- L2缓存单元(L2 Cache)
  - Cortex-A8的缓存可以配置成64k~2M、
  - L1缓存时L2缓存的子集
  - L2缓存和L1缓存之间采用低延迟高带宽接口，降低延迟
- NEON媒体处理引擎
  - 适用于ARM Cortex-A处理器的一种SIMD扩展结构
  - NEON十段流水线
    - NEON指令队列
    - NEON数据队列
    - NEON译码逻辑的两个流水线
    - 三条用于SIMD整数指令的执行流水线
- ETM单元(嵌入式跟踪宏单元)
- 外部接口
  - AXI总线，高性能、高带宽、低延迟内部总线
  - APB总线接口 ETM、CTI和调试寄存器。APB接口与CoreSight调试体系结构
  - ATB接口
  - DFT(design for test)
### 处理器工作模式和状态
- 工作模式
  - user 正常程序执行
  - sys(system) 使用和用户模式相同的寄存器组，用于运行特权
  - svc（supervisor） 系统复位或软件中断时进入该模式，供操作系统使用的保护模式
  - irq(IRQ 外部中断) 低优先级中断发生时进入该模式，常用于普通的外部中断处理
  - fiq(快速中断模式) 高优先级中断发生时进入该模式
  - 数据访问中止(abt) 当存取异常时进入该模式，用于虚拟存储和存储保护
  - 未定义指令中止模式(und) 当执行未定义指令时进入该模式，用于支持硬件协处理器的软件仿真
- 特权模式
  - 为了服务中断或者异常，具有多系统资源的完全访问权限
    - 系统模式
    - 异常模式
- ARM状态和Thumb状态
- ARM状态和Thumb状态之间切换
  - 执行BX和BLX指令时，将通用寄存器的中所存储的目标地址值复制到程序寄存器PC，该目标地址值的最低一位为1则切换到Thumb状态
  - 执行BX和BLX指令时，将通用寄存器的中所存储的目标地址值复制到程序寄存器PC，该目标地址值的最低一位为0则切换到ARM状态
  - 处理器进行异常处理时，把PC的值放入异常模式链接寄存器中，从异常向量地址开始执行程序，系统自动进入ARM状态
  - 如果处理器在Thumb状态时发生异常，当异常处理返回时自动切换到Thumb状态
### Cortex-A8存储器管理
- 32位处理器，支持多种数据类型
- 数据采用二进制格式存储
- 整个 ARM嵌入式系统设计中 寄存器 -> cache -> 主存储器 -> 辅助存储器
  - 又可看成 主存-辅存 和 cache-主存层次
- 寄存器组 A8共有40个32位寄存器 33个通用寄存器和7个状态寄存器
- 状态寄存器
  - 1个CPSR 6个SPSR
- 这些寄存器不能同时访问 R14为 link register
- PC 记录程序当前运行地址，每执行一条都会将pc增加4字节 thumb模式为两个字节
  - ARM状态下 字对齐
- 状态寄存器 
  - 两类状态寄存器
    - 一个当前状态寄存器CPSR
    - 六个备份状态寄存器SPSR
  - 保存最近执行的算数或者逻辑运算的星系，控制中断的允许或者禁止
  - 设置处理器工作模式
  - 每一种处理器模式下使用专用的备份程序状态寄存器
  - CPSR    
    - 32位寄存器会被分成四个域：
        标志位域f (flag field)， PSR[31:24]
        状态域s (status field)， PSR[23:16]
        扩展域x (extend field)，PSR[15:8]
        控制域c (control field)，PSR[7:0]
- MMU
  - 面对一些复杂的、多任务的嵌入式应用时，常使用嵌入式操作系统来管理整个系统和任务的运行
  - 高级的嵌入式操作系统都带有内存管理单元MMU（Memory Management Unit）来管理每个任务各自的存储空间
  - 当应用程序的规模不断增大，超过了内存的增长速度，以至于内存存放不下应用程序时，需要采用了虚拟内存（VirtualMemory）技术
  - 任何时候，计算机上都有一个程序能够产生的地址集合，称为地址范围
  - 与虚拟地址和虚拟地址空间对应的就是物理地址和物理地址空间
  - 虚拟地址由编译器和连接器在定位程序的时候分配
  - 物理地址用于访问实际的主存储器硬件模块
  - 在ARM中采用page式虚拟存储管理方法
- CACHE
  - Cache放置数据的常用地址变换方法
    - 直接映像
    - 组相联映像
    - 全相联映射方式
  - 替换算法
    - 随机
    - lru
    - 循环
  - 存储器写策略
    - 写直达
    - 通过缓存写直达
    - 写回法
### Cortex-A8异常处理
- 异常是ARM处理器处理外部异步事件的一种方法，也称为中断
- 若同时有多个异常发生，处理器将根据异常中断优先级来处理这些异常
- 异常中断
  - 复位异常
  - 未定义指令
  - 软件中断异常
  - 指令预取中止异常
  - 数据访问中止异常
  - 外部中断异常
  - 快速中断异常
- 异常向量和表
  - 异常发生的时候，处理器会将pc寄存器设置为一个特定的存储器地址，这些特定的存储器地址称为异常向量
  - 通常存储器地址映射地址0x00000000是为异常向量表保留的
- 异常(中断)响应
  - 保护断点
  - 寻找中断入口
  - 执行中断处理程序
  - 中断返回
- ARM处理器对异常的响应
  - 进入与特定的异常相应的运行模式
  - 将CPSR寄存器的值保存到将要执行的异常中断各自对应的SPSR_MODE中，以实现对处理器当前运行状态、中断屏蔽和各标志位的保护
  - 将引起异常指令的下一条指令的地址存入相应的链接寄存器LR，以便程序在异常处理结束返回时能正确的返回到原来的程序处继续向下执行
  - 设置CPSR寄存器的低5位，使处理器进入相应的工作模式
  - 根据异常类型，将表中的向量地址赋给pc
  - 每种异常模式对应两个寄存器R13_mode和R14_mode
- 异常返回的过程
  - 复位以后发生后，由于系统自动从0x00000000开始重新执行程序，因此复位异常执行后不需要返回，其他异常需要返回原来程序的断电
  - 恢复过程
    - 恢复原来被保存的用户寄存器
    - 将SPSR_mode寄存器的值复制到CPSR中，以恢复被中断的程序工作状态
    - 根据异常类型将pc寄存器值恢复到断点位置，以执行原来被打断的程序
    - 清除CPSR中的中断屏蔽位I和F，开放中断和快速中断
- Cortex-A8提供了2种中断模式，即FIQ模式和IRQ模式
- 所有的中断源在中断请求时都要确定使用哪一种中断模式
### ARM指令集
- 代码整洁之道(Clean code)
- ARM处理器指令集
  - ARM指令集
    - 原生32位指令
    - 字对齐(4字节边界对齐)
  - Thumb指令集
    - 16位指令集，ARM指令集的子集
    - 2字节边界对齐
    - 具有较高代码密度
    - 保持arm的大多数性能优势
  - Thumb-2指令集
    - 具有16位和32位指令，提供几乎与ARM指令集完全相同的功能
    - 2字节边界对齐，16位和32位指令可自由混合
    - 继承了thumb指令集的高代码密度，又能实现ARM指令集的高性能
  - thumbEE
    - thumb-2指令集的一个变体，用于动态产生的代码
    - 不能与ARM指令集和thumb指令集交织在一起 
- ARM和Thumb-2指令比较
  - 比较并跳转
  - ARM指令集的指令基本格式如下：
    - < opcode > {< cond >} { S } < Rd >, < Rn >, < shift_operand >
  - 每条指令都是32位
- risc-v
  - R型 寄存器寄存器操作的R类型指令
  - I型 短立即数和load操作
  - S型 store操作
  - B型 条件跳转
  - U型 长立即数
  - J型 无条件跳转
- ARM指令集几乎每条指令都可以是条件执行的，由cond可选条件码来决定，位于ARM指令的最高4位
### ARM指令的寻址方式
- 寻址方式：处理器根据指令中给出的地址信息，找出操作数所存在的物理地址
- ARM指令系统支持的寻址方式
  - 立即寻址（Immediate addressing）
  - 寄存器寻址（Register addressing）
  - 寄存器移位寻址（Shifted register addressing）
  - 寄存器间接寻址（Scaled register addressing）
  - 基址变址寻址（Offset addressing）
  - 相对寻址（PC-Relative addressing）
- 立即寻址
  - 立即寻址指令中的操作码字段后面的地址码部分即是操作数本身
- 寄存器偏移寻址
  - ARM指令集特有的寻址方式，又称寄存器移位寻址
  - 第2个寄存器操作数与第1个操作数结合之前，进行移位操作
  - 寄存器移位寻址指令举例：
- 寄存器间接寻址
- 基址变址寻址
- 相对寻址
### ARM指令简介
- ARM指令集有六大类
  - 跳转
  - 数据处理
  - 程序状态寄存器处理
  - 加载、存储指令
  - 协处理器指令
  - 异常产生
- ARM指令集是加载、存储型的
  - 指令的操作数都存储在寄存器中
  - 处理结果直接放入到目的寄存器中
  - 采用专门的load和store
  - 大多数x86指令的操作数和结果都可以是存储器
- 跳转指令
  - 跳转指令用于实现程序流程跳转
  - ARM指令集中的跳转指令可以完成从当前指令向前或向后的32MB地址空间的跳转
  - B {条件}目标地址
  - BL指令
    - BL {条件} 目标地址用于子程序调用
    - 在跳转之前，将下一条指令的地址复制到链接寄存器R14（LR）中，然后跳转到指定地址执行。
  - BLX指令
    - BLX {条件} 目标地址
    - BLX指令从ARM指令集跳转到指定地址执行，并将处理器的工作状态由ARM状态切换到Thumb状态，同时将PC值保存到链接寄存器R14中。
  - BX {条件} 目标地址
    - 带状态切换的跳转指令，跳转到指定地址执行。
    - 若目标地址寄存器的位[0]为1，处理器的工作状态切换为Thumb状态，同时将CPSR中的T标志位置1，目标地址寄存器的位[31:1]复制到PC中
    - 若目标地址寄存器的位[0]为0，处理器的工作状态切换为ARM状态，同时将CPSR中的T标志位清0，目标地址寄存器的位[31:1]复制到PC中。
- 数据处理指令
  - 使用原则
    - 所有操作数都是32位，可以是寄存器或立即数
    - 如果数据操作有结果
    - 两操作数或者三个操作数
    - 数据处理指令只能对寄存器的内容进行操作。指令后都可以使用s后缀来影响标志位
    - 比较指令不需要后缀s，这些指令执行后都会影响标志位
  - MOV指令
  - MOVN
  - ADD
  - SUB
  - RSB 逆向减法指令
  - ADC 将两个操作数相加后，再加上CPSR中的c标志位的值，将结果放入
  - SBC SBC指令用于操作数1减去操作数2，再减去CPSR中的C标志位值的反码，将结果放入目的寄存器中
    - SUBS R0, R0, R2
    - SBC R1, R1, R3
    用于64位数据减法，（R1，R0）=（R1，R0）-（R3，R2）
  - RSC指令
    - RSC {条件}{S} 目的寄存器, 操作数1, 操作数2
    - RSC指令用于操作数2减去操作数1，再减去CPSR中的C标志位值的反码，将结果放入目的寄存器中。
    - 同时根据操作的结果影响标志位。
  - AND
  - ORR
  - EOR 异或
  - BIC 用于清楚操作数1的某些位，将结果放入目的寄存器中
    - BIC {条件}{S} 目的寄存器, 操作数1, 操作数2
    - 2为32位掩码，掩码中设置了哪些位则清楚1中的哪些位
  - CMP指令
    - CMP {条件} 操作数1, 操作数2
    - CMP指令用于把一个寄存器的值减去另一个寄存器的值或者立即数，根据结果设置CPSR中的标志位
  - CMN指令
    - 把一个寄存器的值减去另一个寄存器或者立即数取反的值，根据结果设置CPSR中的标志位，但不保存结果
    - 该指令时间上完成了两个操作数的加法
  - TST
    - TST指令用于把一个寄存器的值和另一个寄存器的值或立即数进行按位与运算，根据结果设置CPSR中的标志位，但不保存结果。
  - TEQ
    - 用于将一个寄存器的值和另一个寄存器的值或立即数进行按位异或运算，并根据结果更新程序状态寄存器 CPSR 中的标志位
    - 常用于检测两个操作数是否相等
- 程序状态寄存器处理指令
  - MRS指令和MSR指令用于在状态寄存器和通用寄存器之间传输数据
  - 状态寄存器的值要通过"读取->修改->写回"三个步骤操作来实现
  - MRS指令和MSR指令的格式如下：
    - MRS {条件} 通用寄存器, 程序状态寄存器（CPSR或SPSR）
    - MSR {条件} 程序状态寄存器（CPSR或SPSR）_<域>, 操作数
    - MSR指令中的<域>可用于设置程序状态寄存器中需要操作的位：
      - 位[31：24]为条件标志位域，用f表示。
      - 位[23：16]为状态位域，用s表示。
      - 位[15：8]为扩展位域，用x表示。
      - 位[7：0]为控制位域，用c表示。
- 加载/存储指令
  - 用于在寄存器和存储器之间传输数据
  - LDR指令
    - LDR指令将一个32位字数据传输到目的寄存器中
    - 如果目的寄存器是PC，从存储器中读出的数据将作为目的地址，以实现程序流程的跳转
  - STR指令
    - STR {条件} 源寄存器, <存储器地址>
    - STR指令用于从源寄存器中将一个32位字数据写入存储器中、
  - LDM和STM指令
    - LDM（或STM）{条件}{类型} 基址寄存器{！}, 寄存器列表{∧}
  - 堆栈寻址
    - 堆栈是一个按特定顺序进行存取的存储区，操作顺序为“后进先出”
    - 堆栈寻址是隐含的，使用一个专门的寄存器指向一块存储区域，指针所指向的存储单元即是堆栈栈顶
    - 存储器堆栈可分为两种，向上生长：向高地址方向生长 递增 向下生长 向低地址方向生长 递减
    - 堆栈指针指向最后压入的堆栈的有效数据顶，称为满堆栈
    - 堆栈指针指向下一个待压入数据的空位置，称为空堆栈
    - 可以组合出四种类型的堆栈方式：
      - 满递增：堆栈向上增长，堆栈指针指向内含有效数据项的最高地址。指令如LDMFA、STMFA等
      - 空递增：堆栈向上增长，堆栈指针指向堆栈上的第一个空位置。指令如LDMEA、STMEA等
      - 满递减：堆栈向下增长，堆栈指针指向内含有效数据项的最低地址。指令如LDMFD、STMFD等
      - 空递减：堆栈向下增长，堆栈指针向堆栈下的第一个空位置。指令如LDMED、STMED等
  - SWP指令
    - SWP{条件} 目的寄存器, 源寄存器1, [源寄存器2]
    - SWP指令用于将源寄存器2所指向的存储器中的字数据传输到目的寄存器中，同时将源寄存器1中的字数据传输到源寄存器2所指向的存储器中。
    - 当源寄存器1和目的寄存器为同一个寄存器时，该指令完成该寄存器和存储器内容的交换。
- 异常产生指令
  - 软中断指令(SWI)
    - SWI {条件} 24位立即数
    - 用于产生SWI异常中断
    - 实现从用户模式切换到管理模式，CPSR保存到管理模式下的SPSR，执行转移到SWI向量
    - 其他模式下也可以使用SWI指令，同样切换到管理模式
  - 断点中断指令
    - BKPT 16位立即数
    - 产生软件断点中断，软件调试程序可以使用这个中断
    - 立即数会被硬件忽略，能被调试工具利用来得到有用的信息、
- Thumb指令集
  - 为了兼容存储系统总线宽度为16位的应用系统，ARM体系结构中提供了16位Thumb指令集
  - 可以看作是ARM指令压缩形式的子集
    - 具有16位的代码密度，对于嵌入式系统来说至关重要
  - Thumb不是一个完整的体系结构，不能指望处理器只执行Thumb指令而不支持ARM指令集。
  - Thumb子程序和ARM子程序可以互相调用。
    - 当处理器在执行ARM程序段时，称ARM处理器处于ARM工作状态
    - 当处理器在执行Thumb程序段时，称ARM处理器处于Thumb工作状态。
  - 没有协处理器、信号量指令、访问CPSR或SPSR的指令、乘加指令以及64位乘法指令
  - Thumb指令的第二操作数受到限制
  - 除了分支指令B有条件执行，其他无条件执行
  - 数据处理指令
    - 数据处理指令是对通用寄存器进行操作，在大多数情况下，操作的结果须放入其中一个操作数寄存器中，而不是第3个寄存器中。
    - 数据处理操作比ARM状态的更少。
    - 访问R8～R15受到一定限制：除MOV和ADD指令访问寄存器R8～R15外，其他数据处理指令总是更新CPSR中的ALU状态标志；
    - 访问寄存器R8～R15的Thumb数据处理指令不能更新CPSR中的ALU状态标志。
  - 单寄存器加载和存储指令 在Thumb状态下，单寄存器加载和存储指令只能访问寄存器R0～R7。
  - 多寄存器加载和多寄存器存储指令
    - LDM和STM指令可以将任何范围为R0～R7的寄存器子集加载或存储。
    - PUSH和POP指令使用堆栈指针R13作为基址实现满递减堆栈。
    - 除R0～R7外，PUSH指令还可以存储链接寄存器R14，并且POP指令可以加载程序计数器PC
- ARM汇编语言程序简介
  - 反汇编并进行跟踪是逆向工程的主要手段
  - 软件保护也需要在汇编上下功夫
  - 汇编-并行指令
  - 汇编语言程序由机器指令、伪指令和伪操作组成的
  - 伪操作
    - 一些特殊的指令助记符
    - 符号定义伪操作
      - .global 定义全局变量
      - .local 定义局部变量 
    - 数据定义伪操作
      - .byte 分配一段字节的内存单元，并用指定的数据初始化
      - .word 分配一段字
      - .dword 分配一段双字的内存单元
      - .asciz 分配一段以0结尾的字符串空间
      - .skip 变量保留特定的存储量
    - 其他伪操作
      - .align 边界对齐
      - .section 段定义
      - .arm 32位ARM指令
      - .end 汇编结束
      - .equ 常量定义
  - 段 section 是ARM汇编中组织源文件的基本单位，是独立的，具有特定名称的，不可分割的指令或数据序列
    - 代码段和数据段
    - ARM至少需要一个代码段
  - axm bin elf hex
  - 可执行的映像文件至少三个部分
    - 一个或多个代码段 只读
    - 零个或多个包含初始化数据的数据段，属性为可读可写
    - 零个或多个不保护初始化数据的数据段，可读可写
    - 连接器按照一定规律将各个段放在内存中
- C语言与汇编语言的混合编程
  - ARM体系结构不仅支持汇编，也支持c语言
    - 常用嵌入式设计语言，可读性高，移植性好，可靠性高
  - 一些情况需要二者混合编程
  - C程序中内嵌汇编
    - 在 ARM C 语言程序中，可以使用关键词 "__asm" 或 "asm" 来标识一段汇编指令代码。这两个关键词的使用方法类似，可以根据需要选择适合的关键词来使用。其语法格式如下：
    - 使用 "__asm" 关键词：
      __asm {
          汇编指令1;
          汇编指令2;
          ...
      }
    - 使用 "asm" 关键词：
      asm (
          "汇编指令1;"
          "汇编指令2;"
          ...
      );
    - 其中，"汇编指令1"、"汇编指令2" 等为要执行的汇编指令代码。多条指令之间可以使用分号 ";" 来隔开。如果一条指令占多行，使用\符号
  - 在C语言中声明的全局变量可以被汇编语言通过地址间接访问。
    - 例如，在C语言程序中已经声明了一个全局变量glovbvar，通过.global伪指令声明外部变量的方式访问：
  - 为了使单独编译的C语言程序和汇编语言程序之间能够相互调用，必须遵守ATPCS规则。
  - 基本ATPCS规定了在子程序调用时的一些基本规则，包括3个方面的内容：
    - 各寄存器的使用规则机器相应的名称。
    - 数据栈的使用规则。
    - 参数传递的规则。
- S5PV210 微处理器与接口
  - 体系结构
    - S5PV210又名峰鸟
      - 三星推出的应用处理器
      - 采用cortex-A8
      - ARM-V7指令集
      - 1GHz
      - 64/32位内部总线
    - 主要由6大部分组成:cpu核心、系统外设、多媒体、电源管理、存储器接口和连接模块
    - cpu与各个部分通过多层次ahb和axi总线来完成连接
    - Cortex A8处理器
      - 运行速度在600MHZ~1GHZ时，功率小于300mW
      - 第一个超标量处理器，用于增强代码密度和性能
      - 支持jazelleRCT技术用于即时编译java
      - 13级主整数流水
    - NEON
      - 可以实现图像的只能分析、数学运算等复杂算法
    - 32KB I/O缓存、512KB L2 Cache 
  - 存储系统
    - 地址空间
      - 特殊功能寄存器区
      - 隔离rom区
      - 音频存储区
      - flash区
      - 静态只读存储区(SROM)区
      - 动态随机存储器(DRAM)区
      - 引导区
  - 启动流程
    - S5PV210的启动过程由BL0、BL1和BL2（BL为BootLoader的简称）3部分代码实现
      - 其中BL0在出厂时就已经被固化到了64KB的iROM中
    - S5PV210上电后首先执行BL0，该段代码主要的工作序列如下所示：
      - （1）关看门狗时钟。
      - （2）初始化指令cache。
      - （3）初始化栈、堆。
      - （4）初始化块设备复制函数。
      - （5）初始化PLL及设置系统时钟。
      - （6）根据OM引脚设置，从相应启动介质复制BL1到片内SRAM的0xD002_0000地址处
（其中0xD002_0010之前的16个字节存储的是BL1的校验信息和BL1的大小），并检查BL1的checksum信息，如果检查失败，IROM将自动尝试第二次启动（从SDMMC channel 2启动）。
      - （7）检查是否是安全模式启动，如果是则验证BL1完整性
      - （8）跳转到BL1起始地址处
    - BL1大小很小，负责工作较少
    - BL2实际上是整个Bootloader的主体部分
      - 完成更多的初始化工作，例如初始化网卡，flash等
      - BL2读取操作系统镜像到内存中运行
      - 操作系统镜像的存放位置根据具体开发平台决定，一般放flahs上，也可以放sd卡里面‘
    - 时钟系统
      - CPU的系统时钟源主要是外部晶振，内部其他部分的时钟都是将外部时钟源经过一定的分频或倍频得到的。
      - 外部时钟源的频率一般不能满足系统所需要的高频条件，所以往往需要PLL锁相环先进行倍频处理
      - 三个时钟域
        - 主时钟域(MSYS)
          - 用来给CORTEX-A8处理器、DRAM控制器、3D、内部存储器（IRAM和IROM）、芯片配置界面（SPERI）、中断控制器等提供时钟
        - 显示相关的时钟域(DSYS)
          - 用来给显示相关的部件提供时钟，包括FIMC、FIMD、JPEG、IPS多媒体等
        - 外围设备的时钟域(PSYS)
          - 用来给外围设备、安全子系统、低功率音频播放等提供时钟
        - 时钟可以通过选择、预分频、提供给其他的扩展模块  时钟管理单元(CMU)
      - 210刚上电的时候，默认是外部晶振+内部时钟发生器产生的24Mhz频率的时钟直接给ARMCLK的
      - iROM代码执行时第5步初始化了时钟系统，采用默认推荐运行频率
    - 定时器编程过程
      - 设置预分频器，时钟分频器
      - 设置TCNTB0，TCMPB0寄存器的值
      - 程序设置允许手动更新，timer0 自动将TCNTB0、TCMPB0的值加载到Timer0内部的TCNT0和TCMP0寄存器
  - 接口
    - GPIO全称是通用编程I/O端口，是cpu的引脚
      - 通过GPIO向外输出高低电平，或者读入引脚的状态
      - 这里的状态通过高电平或低电平来反应
    - 每个GPIO端口至少需要两个寄存器
      - 控制寄存器
      - 数据寄存器
      - 控制与数据寄存器每一位都与GPIO的硬件引脚相对应
      - 由控制寄存器设置每一个引脚的数据流向
    - GPIO寄存器
      - 每组GPIO端口都有两类控制寄存器
        - 分别工作在正常模式和掉电模式
      - S5pv210处理器工作在正常模式下时，正常寄存器工作
      - 进入掉电模式时，所有配置和上拉下拉控制由掉电寄存器控制
      - GPIO控制寄存器GPxnCON  
        - 用于控制GPIO的引脚功能，向该寄存器写入数据来设置相应引脚时输入输出还是其他功能
        - 该寄存器中每四位控制一个引脚，写入0000设置为输入接口，读入外部输入的数据
        - 写入0001设置为输出IO，向该位写入的数据被发送到对应的引脚上
        - 写入其他值可以设置引脚的第二功能
      - 数据寄存器GPxnDAT
        - 用于读写引脚的状态，即该端口的数据
        - 当引脚被设置为输出引脚，写该寄存器对应位为1，设置该引脚输出高电平，写入0设置该引脚输出低电平
        - 当引脚被设置为输入引脚，读取该寄存器对应位中的数据可得到端口电平状态
      - 上拉/下拉寄存器GPxnPUD
        - 用于控制每个端口上拉/下拉电阻的使能禁止
        - 0 使用电阻
        - 1 不使用
      - 掉电模式上拉/下拉寄存器 GPxnPUDPDN
        - 用于掉电模式下使用
        - 每两位对应一个引脚，为00时输出为0，01时输出1，10时为输入功能，11时保持原有状态
    - GPIO操作步骤
      - 确定所使用的GPIO端口的功能
        - 如作为输入/输出引脚使用时，是否需要设置
      - 确定输入输出方向
      - 对数据寄存器进行操作
  - 串行通信接口
    - 串行通信
      - 数据一位一位的按顺序传送
      - 优点 一根线 适合远距离传输
      - 缺点 速度慢
    - 并行
      - 数据各位同时进行传送
      - 速度快
      - 有多少位数据就有多少根传输线，这在数据位数较多，传送距离较远时不宜采用
    - 异步传送
      - 数据在线路上是以一个字为单位
      - 可以连续也可以间断
      - 异步传输，发送方和接送方各采用自己的时钟源来控制发送和接受
    - 同步传送
      - 收发双方需要保持时钟同步
    - 210处理器中采用的是异步串行通信(uart)方式
      - 发送端和接收端采用的不是同一个时钟
      - 以字符为单位组成字符帧传送
    - RS-232C串行接口
      - RS-232C标准协议的全称是EIA-RS-232C标准
      - 其中EIA代表美国电子工业协会
      - RS代表推荐标准
      - 232是标识号，C代表最新一次修改(1969)
      - 规定连接电缆、机械、电气特性、信号功能以及传送过程
    - UART结构和收发过程
      - 每个UART包含一个波特率发生器、一个发送器、一个接收器和一个控制单元
      - 波特率发生器使用PCLK或SCLK_UART，发送器和接收器包含FIFO和数据移位寄存器
      - 要发送的数据被写入Tx FIFO，然后被复制到发送移位寄存器，随后被发送引脚TxDn移出
      - 接收数据时，数据通过RxDn引脚移位进入接收移位寄存器中，最后被复制到Rx FIFO
    - 在数据通信过程中，有一个状态寄存器UTRSTATn来描述当前状态下的发送状态和接收状态
      - 通过查看状态寄存器中的相应位的值就可以确定当前状态下发送和接收的状态，从而判断是否可以发送数据，是否有新的数据到来。
      - 每个UART波特率发送器为发送器和接收器提供串行时钟波特率发生器的时钟源可以通过UCONn寄存器中的时钟选择位来选择PCLK或SCLK_UART
      - 波特率是将时钟源和波特率除数寄存器（UBRDIVn）的值相除得到的。计算公式为：
        - UBRDIVn = [PCLK /(波特率  16)] − 1
### ARM-Linux内核
- 概述
  - 一体化内核系统系统
  - 内核指的是一个提供硬件抽象层、磁盘以及文件系统控制、多任务等功能的系统软件，一个内核不是一套完整的操作系统
  - linux操作系统的灵魂是内核
  - ARM-Linux内核是专门适应ARM体系结构设计的Linux内核，它负责整个系统的：
    - 进程管理和调度
    - 内存管理
    - 文件管理
    - 设备管理
    - 网络管理
  - 用户空间
    - 包括用户应用程序和GNU C库
      - 负责执行用户应用程序
    - 不同的编译环境使用glibc版本可能不一样
  - 内核空间进一步分为三层
    - 系统调用接口
    - 独立于体系结构的内核代码
    - 依赖于体系结构的代码 BSP
  - 嵌入式Linux系统内核往往在标准Linux基础上通过安装补丁的方式来实现
  - 在2.6版本之前，Linux内核版本的命名格式为 “A.B.C”
    - A是内核版本号
    - B是内核主版本号，主版本号根据传统的奇偶系统版本编号来分配 奇数为开发版，偶数为稳定版
  - Linux是一个内核运行在单独的内核地址空间的单内核，但是汲取了微内核的精华如模块化设计、抢占式内核、支持内核线程以及动态装载内核模块等特点
  - 以2.6版本为例子
    - 支持动态加载内核模块机制
    - 支持对称多处理机制(SMP)
    - o(1)调度算法
    - linux内核可抢占，linux内核具有允许在内核运行的任务优先执行的能力
    - linux不区分线程和其他一般的进程，对内核来说，所有的进程都一样
    - linux提供具有设备类的面向对象的设备模块、热插拔事件，以及用户空间的设备文件系统
  - ARM-linux内核的主要架构以及功能
    - 系统调用接口
    - 进程管理 进程间通信 内存管理 虚拟文件系统 网络管理 设备管理
    - cpu 存储器 外设 网络设备
    - 进程间通信
      - 不同进程之间的通信是操作系统的基本功能之一
      - linux内核通过支持posix规范中标准的IPC机制和其他许多广泛使用的IPC机制实现进程间通信
      - IPC不管理任何硬件，他主要负责linux系统中进程之间的通信
- ARM-Linux进程管理
  - 进程是处于执行期的程序以及它所管理的资源的总称
  - 进程管理是linux内核中最重要的子系统，主要提供对cpu的访问控制
  - 对于计算机中，cpu资源是有限的，众多的应用程序都要使用cpu资源，所以需要进程调度子系统对cpu进行调度管理
  - 调度子系统模块
    - scheduling policy模块
      - 该模块实现进程调度的策略，它决定哪个进程将拥有cpu资源
    - Architecture-specific schedulers 模块
      - 该模块涉及体系结构相关部分，用于将对不同cpu的控制抽象为统一的接口
      - 这些控制功能主要在suspend和resume进程时候使用，包含访问寄存器，汇编指令操作
    - Architecture-independent Scheduler模块
      - 该模块设计体系结构无关部分
    - system call interface 系统调用接口
      - 进程调度子系统通过系统调用接口将需要提供给用户空间的接口开放出去
      - 同时屏蔽掉不需要用户空间程序关心的细节
  - 进程的表示和切换
    - linux内核通过一个被称为进程描述符的task_struct结构体 记录了进程最基本的信息
      - 标识符(PID)
      - 状态:任务状态，退出代码，退出信号等
      - 优先级:相对于其他进程的优先级
      - 程序计数器
      - 内存指针 包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
      - 上下文数据：进程执行时处理器的寄存器中的数据
      - I/O状态信息，包括显示的I/O请求，分配给进程的I/O设备和被进程使用的文件列表
      - 记账信息，可能包括处理器事件总和，使用的时钟数总和，时间限制，记账号等
    - 进程描述符中不仅包含了许多描述进程属性的字段，而且害包含一系列指向其他数据结构的指针
    - 内核把每个进程的描述符放在一个叫做任务队列的双向循环列表中
  - 进程、线程和内核线程
    - 进程是系统资源分配的基本单位，线程是程序独立运行的基本单位
    - 线程之间独享和栈有关的资源，共享与栈无关的资源
      - 栈
      - 寄存器
      - 程序计数器
      - 状态机
    - linux中，内核采用进程、线程和内核线程统一管理的方法实现进程管理
    - 内核将进程、线程和内核线程一视同仁
    - 内核线程永远运行在内核态
  - fork
  - vfork
    - 一样都是在已有的进程中创建一个新的进程，但是他们创建的子进程还是有区别的
    - 父子进程的执行顺序
      - fork():父子进程的执行顺序不确定
      - vfork 保证子程序先运行，在它调用exec/exit，父进程才执行
    - 是否拷贝父进程的地址空间
      - fork 子进程拷贝父进程的地址空间，子进程是父进程的一个复制品
      - vfork 子进程共享父进程的地址空间调用
    - 调用vfork函数，是为了执行exec函数 如果子进程没有调用exec/exit 程序会出错
  - do_fork()
    - 内核中创建进程的核心函数为do_fork，该函数原型如下
  - fork()
    - 子进程完全复制父进程的资源，也就是说父子进程相对独立
      - 引入写时复制技术
      - 子进程可以只读父进程的物理页
      - 只有当父进程或者子进程去写某个物理页时候，内核此时才会把这个页的内容拷贝到一个新的物理页，并把这个新的物理页分配给正在写的进程
  - vfork()
    - do_fork clone_flags 使用了clone_vfork 和 clone_vm 两个标志
      - clone_vfork 进程先于父进程执行，父进程会阻塞到子进程结束或执行新的程序
      - clone_vm    让子进程可以共享父进程的地址空间
    - 在写时复制技术引入之前，vfork()适用子进程形成后立即执行execv()的情形
    - 没有特别的使用指出，写时复制技术完全可以取代创建进程带来的高效性
  - clone()
    - 通常用于创建轻量级进程
    - 通过传递不同的标志可以对父子进程之间数据共享和复制做精确的控制
      - CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND
    - 由上述标志可以看到，轻量级进程通常共享父进程的内存地址空间、父进程所在的文件系统的根目录以及工作目录信息、父进程当前打开的文件以及父进程所拥有的信号处理函数
  - Linux中的进程调度
    - linux既支持普通的分时进程，也支持实时进程
    - linux中调度是多种策略和方法的混合
    - 调度基于分时和优先级
    - linux进程根据优先级排队
    - linux进程的优先级是动态
      - 调度程序会根据进程的行为周期性的调整进程的优先级
    - 主动调度和被动调度
      - 主动调度随时可以开始，内核中通过schedule()启动调度
    - 调度算法
      - 2.4调度算法
        - 可运行队列，算法O(n)
        - Epoch 基本事件片，动态优先级
      - linux 2.6内核后实现了抢占式优先级
        - 处理完中断之后，立即引发调度，切换到高权值
        - 支持内核代码可抢占
      - linux2.6.17调度算法
        - 非实时:cfs vruntime 红黑树
        - 实时 优先级队列
      - linux进程课程指定该进程所采用的调度策略
    - 进程调度原理
    - 进程间的通信方式
      - 必要性
        - 每一个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须要通过内核
      - 解决方法，内核中开辟缓冲区
      - 管道 pipe 有名管道 named pipe
        - 用于具有亲缘关系进程之间的通信
        - 有名管道允许无亲缘关系进程之间的通信
      - 共享内存(shared memory )
        - 多个进程可以访问同一块内存空间
        - 可以及时看到对方进程中对共享内存中数据的更新
        - 需要依靠某种同步机制
      - 消息队列
        - 消息队列是消息的连接表
        - 克服了前两种通信方式信息量有限的缺点
        - 具有写权限的进程可以按照一定的规则向消息队列中添加新消息，对消息队列有读权限的进程则可以从消息队列中读取消息
      - 常见通信方式
        - 信号
          - signal
          - 软件层次上对中断机制的模拟
          - 用于通知进程有事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一样的
        - 信号量
          - semaphore
          - 进程之间以及同意进程的不同线程之间的同步和互斥手段
        - 套接字
          - Socket
          - 可用于网络中不同机器之间的进程间通信
      - 管道是一种最基本的进程机制
        - 由pipe函数创建
        - 调用pipe函数时在内核中开辟一块缓冲区用于通信
      - 共享内存
        - shmget()创建共享内
      - 线程同步
        - 多线程编程，无法知道哪个线程会在哪个时候对共享资源进行操作，因此让如何保护共享资源变得复杂
        - 解决线程之间对资源的竞争的途径
          - 互斥锁(互斥量)Mutex
            - 本质上就是一把锁，提供对共享资源的保护访问
          - 信号量semaphore
            - 互斥锁只允许一个线程访问被保护的资源
            - 信号量允许多个线程同时访问被保护的资源
- ARM-Linux内存管理
  - 内存管理是Linux内核中最重要的子系统之一，它主要提供对内存资源的访问控制机制
  - 这种机制主要涵盖了
    - 内存的分配和回收
    - 地址转换
    - 内存扩充
    - 内存的共享与保护
  - linux系统会在硬件物理内存和进程所使用的内存 建立映射